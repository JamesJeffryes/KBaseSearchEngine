package kbaserelationengine.events.handler;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import com.fasterxml.jackson.core.type.TypeReference;

import kbaserelationengine.common.GUID;
import kbaserelationengine.events.ObjectStatusEvent;
import kbaserelationengine.events.ObjectStatusEventType;
import us.kbase.common.service.JsonClientException;
import us.kbase.common.service.Tuple11;
import us.kbase.common.service.UObject;
import workspace.GetObjectInfo3Params;
import workspace.GetObjectInfo3Results;
import workspace.GetObjects2Params;
import workspace.GetObjects2Results;
import workspace.ListObjectsParams;
import workspace.ObjectData;
import workspace.ObjectIdentity;
import workspace.ObjectSpecification;
import workspace.ProvenanceAction;
import workspace.SubAction;
import workspace.WorkspaceClient;

/** A handler for events generated by the workspace service.
 * @author gaprice@lbl.gov
 *
 */
public class WorkspaceEventHandler implements EventHandler {
    
    //TODO TEST

    /** The storage code for workspace events. */
    public static final String STORAGE_CODE = "WS";
    
    private static final int WS_BATCH_SIZE = 10_000;
    
    private static final TypeReference<List<Tuple11<Long, String, String, String,
            Long, String, Long, String, String, Long, Map<String, String>>>> OBJ_TYPEREF =
                    new TypeReference<List<Tuple11<Long, String, String, String,
                        Long, String, Long, String, String, Long, Map<String, String>>>>() {};
    
    private final WorkspaceClient ws;
    
    /** Create a handler.
     * @param wsClient a workspace client to use when contacting the workspace service.
     */
    public WorkspaceEventHandler(final WorkspaceClient wsClient) {
        ws = wsClient;
    }
    
    @Override
    public SourceData load(final GUID guid, final Path file) {
        return load(Arrays.asList(guid), file);
    }

    @Override
    public SourceData load(final List<GUID> guids, final Path file) {
        // create a new client since we're setting a file for the next response
        // fixes race conditions
        // a clone method would be handy
        final WorkspaceClient wc;
        try {
            wc = new WorkspaceClient(ws.getURL(), ws.getToken());
        } catch (IOException |JsonClientException e) {
            //TODO EXP some of these exceptions should be retries, some should shut down the event loop until the issue can be fixed (e.g. bad token, ws down), some should ignore the event (ws deleted)
            throw new IllegalStateException("Error contacting workspace: " + e.getMessage(), e);
        }
        wc.setIsInsecureHttpConnectionAllowed(ws.isInsecureHttpConnectionAllowed());
        wc.setStreamingModeOn(true);
        wc._setFileForNextRpcResponse(file.toFile());
        final Map<String, Object> command = new HashMap<>();
        command.put("command", "getObjects");
        command.put("params", new GetObjects2Params().withObjects(
                Arrays.asList(new ObjectSpecification().withRef(toWSRefPath(guids)))));
        final ObjectData ret;
        try {
            ret = wc.administer(new UObject(command))
                    .asClassInstance(GetObjects2Results.class)
                    .getData().get(0);
        } catch (IOException |JsonClientException e) {
            //TODO EXP some of these exceptions should be retries, some should shut down the event loop until the issue can be fixed (e.g. bad token, ws down), some should ignore the event (ws deleted)
            throw new IllegalStateException("Error contacting workspace: " + e.getMessage(), e);
        }
        // we'll assume here that there's only one provenance action. This may need more thought
        // if that's not true.
        final ProvenanceAction pa = ret.getProvenance().isEmpty() ?
                null : ret.getProvenance().get(0);
        final String creator = ret.getCreator();
        String copier = ret.getInfo().getE6();
        if (ret.getCopied() == null & ret.getCopySourceInaccessible() == 0) {
            copier = null;
        }
        final SourceData.Builder b = SourceData.getBuilder(ret.getData(), ret.getInfo().getE2())
                .withNullableCreator(creator)
                .withNullableCopier(copier);
        if (pa != null) {
            b.withNullableModule(pa.getService())
                    .withNullableMethod(pa.getMethod())
                    .withNullableVersion(pa.getServiceVer());
            /* this is taking specific knowledge about how the KBase execution engine
             * works into account, which I'm not sure is a good idea, but for now it'll do 
             */
            if (pa.getService() != null &&
                    pa.getMethod() != null &&
                    pa.getSubactions() != null &&
                    !pa.getSubactions().isEmpty()) {
                final String modmeth = pa.getService() + "." + pa.getMethod();
                for (final SubAction sa: pa.getSubactions()) {
                    if (modmeth.equals(sa.getName())) {
                        b.withNullableCommitHash(sa.getCommit());
                    }
                }
            }
        }
        return b.build();
    }

    @Override
    public Iterable<ObjectStatusEvent> expand(final ObjectStatusEvent event) {
        if (!STORAGE_CODE.equals(event.getStorageCode())) {
            throw new IllegalArgumentException("This handler only accepts "
                    + STORAGE_CODE + "events");
        }
        if (ObjectStatusEventType.NEW_ALL_VERSIONS.equals(event.getEventType())) {
            return handleNewAllVersions(event);
        } else if (ObjectStatusEventType.COPY_ACCESS_GROUP.equals(event.getEventType())) {
            return handleNewAccessGroup(event);
        } else if (ObjectStatusEventType.DELETE_ACCESS_GROUP.equals(event.getEventType())) {
        	return handleDeletedAccessGroup(event);
        } else {
            return Arrays.asList(event);
        }
    }

    private Iterable<ObjectStatusEvent> handleDeletedAccessGroup(final ObjectStatusEvent event) {
        
        return new Iterable<ObjectStatusEvent>() {

            @Override
            public Iterator<ObjectStatusEvent> iterator() {
                return new StupidDeletedWorkspaceIterator(event);
            }
            
        };
    }
    
    /* This is not efficient, but allows parallelizing events by decomposing the event
     * to per object events. That means the parallelization can run on a per object basis.
     * Workspace deletions should be rare anyway.
     */
    private static class StupidDeletedWorkspaceIterator implements Iterator<ObjectStatusEvent> {

        private final ObjectStatusEvent event;
        private final long maxObjectID;
        private long counter = 0;
        
        public StupidDeletedWorkspaceIterator(final ObjectStatusEvent event) {
            this.event = event;
            maxObjectID = Long.parseLong(event.getAccessGroupObjectId());
        }

        @Override
        public boolean hasNext() {
            return counter < maxObjectID;
        }

        @Override
        public ObjectStatusEvent next() {
            if (counter >= maxObjectID) {
                throw new NoSuchElementException();
            }
            return new ObjectStatusEvent(
                    null, // no mongo id
                    STORAGE_CODE,
                    event.getAccessGroupId(),
                    ++counter + "",
                    null, // no ver
                    null, // no rename
                    null, // not a datapalette share
                    event.getTimestamp(),
                    null, // no type
                    ObjectStatusEventType.DELETE_ALL_VERSIONS,
                    null); // no global access rule
        }
        
    }

    private Iterable<ObjectStatusEvent> handleNewAccessGroup(final ObjectStatusEvent event) {
        return new Iterable<ObjectStatusEvent>() {

            @Override
            public Iterator<ObjectStatusEvent> iterator() {
                return new WorkspaceIterator(ws, event);
            }
            
        };
    }
    
    private static class WorkspaceIterator implements Iterator<ObjectStatusEvent> {
        
        private final WorkspaceClient ws;
        private final ObjectStatusEvent sourceEvent;
        private final int accessGroupId;
        private long processedObjs = 0;
        private LinkedList<ObjectStatusEvent> queue = new LinkedList<>();

        public WorkspaceIterator(final WorkspaceClient ws, final ObjectStatusEvent sourceEvent) {
            this.ws = ws;
            this.sourceEvent = sourceEvent;
            this.accessGroupId = sourceEvent.getAccessGroupId();
            fillQueue();
        }

        @Override
        public boolean hasNext() {
            return !queue.isEmpty();
        }

        @Override
        public ObjectStatusEvent next() {
            if (queue.isEmpty()) {
                throw new NoSuchElementException();
            }
            final ObjectStatusEvent event = queue.removeFirst();
            if (queue.isEmpty()) {
                fillQueue();
            }
            return event;
        }

        private void fillQueue() {
            // as of 0.7.2 if only object id filters are used, workspace will sort by
            // ws asc, obj id asc, ver dec
            
            final ArrayList<ObjectStatusEvent> events;
            final Map<String, Object> command = new HashMap<>();
            command.put("command", "listObjects");
            command.put("params", new ListObjectsParams()
                    .withIds(Arrays.asList((long) accessGroupId))
                    .withMinObjectID((long) processedObjs + 1)
                    .withShowHidden(1L)
                    .withShowAllVersions(1L));
            try {
                events = buildEvents(sourceEvent, ws.administer(new UObject(command))
                        .asClassInstance(OBJ_TYPEREF));
            } catch (JsonClientException | IOException e) {
                //TODO EXP some of these exceptions should be retries, some should shut down the event loop until the issue can be fixed (e.g. bad token, ws down), some should ignore the event (ws deleted)
                throw new IllegalStateException("Error contacting workspace: " + e.getMessage(),
                        e);
            }
            if (events.isEmpty()) {
                return;
            }
            // might want to do something smarter about the extra parse at some point
            final long first = Long.parseLong(events.get(0).getAccessGroupObjectId());
            final ObjectStatusEvent lastEv = events.get(events.size() - 1);
            long last = Long.parseLong(lastEv.getAccessGroupObjectId());
            // it cannot be true that there were <10K objects and the last object returned's
            // version was != 1
            if (first == last && events.size() == WS_BATCH_SIZE && lastEv.getVersion() != 1) {
                //holy poopsnacks, a > 10K version object
                queue.addAll(events);
                for (int i = lastEv.getVersion(); i > 1; i =- WS_BATCH_SIZE) {
                    fillQueueWithVersions(first, i - WS_BATCH_SIZE, i);
                }
            } else {
                // could be smarter about this later, rather than throwing away all the versions of
                // the last object
                // not too many objects will have enough versions to matter
                if (lastEv.getVersion() != 1) {
                    last--;
                }
                for (final ObjectStatusEvent e: events) {
                    if (Long.parseLong(e.getAccessGroupObjectId()) > last) { // *&@ parse
                        break;
                    }
                    queue.add(e);
                }
            }
            processedObjs = last;
        }

        // startVersion = inclusive, endVersion = exclusive
        private void fillQueueWithVersions(
                final long objectID,
                int startVersion,
                final int endVersion) {
            if (startVersion < 1) {
                startVersion = 1;
            }
            final List<ObjectSpecification> objs = new LinkedList<>();
            for (int ver = startVersion; ver < endVersion; ver++) {
                objs.add(new ObjectSpecification()
                        .withWsid((long) accessGroupId)
                        .withObjid(objectID)
                        .withVer((long) ver));
            }
            final Map<String, Object> command = new HashMap<>();
            command.put("command", "getObjectInfo");
            command.put("params", new GetObjectInfo3Params().withObjects(objs));
            try {
                queue.addAll(buildEvents(sourceEvent, ws.administer(new UObject(command))
                        .asClassInstance(GetObjectInfo3Results.class).getInfos()));
            } catch (JsonClientException | IOException e) {
                //TODO EXP some of these exceptions should be retries, some should shut down the event loop until the issue can be fixed (e.g. bad token, ws down), some should ignore the event (ws deleted)
                throw new IllegalStateException("Error contacting workspace: " + e.getMessage(),
                        e);
            }
        }
    }

    private Iterable<ObjectStatusEvent> handleNewAllVersions(final ObjectStatusEvent event) {
        final long objid;
        try {
            objid = Long.parseLong(event.getAccessGroupObjectId());
        } catch (NumberFormatException ne) {
            //TODO EXP this exception should prevent the event from being processed again
            throw new IllegalStateException("Illegal workspace object id: " +
                    event.getAccessGroupObjectId());
        }
        final Map<String, Object> command = new HashMap<>();
        command.put("command", "getObjectHistory");
        command.put("params", new ObjectIdentity()
                .withWsid((long) event.getAccessGroupId())
                .withObjid(objid));
        try {
            return buildEvents(event, ws.administer(new UObject(command))
                    .asClassInstance(OBJ_TYPEREF));
        } catch (JsonClientException | IOException e) {
            //TODO EXP some of these exceptions should be retries, some should shut down the event loop until the issue can be fixed (e.g. bad token, ws down), some should cause the event to be ignored (deleted object)
            throw new IllegalStateException("Error contacting workspace: " + e.getMessage(),
                    e);
        }
    }

    private static ArrayList<ObjectStatusEvent> buildEvents(
            final ObjectStatusEvent originalEvent,
            final List<Tuple11<Long, String, String, String, Long, String, Long, String,
                    String, Long, Map<String, String>>> objects) {
        final ArrayList<ObjectStatusEvent> events = new ArrayList<>();
        for (final Tuple11<Long, String, String, String, Long, String, Long, String, String,
                Long, Map<String, String>> obj: objects) {
            events.add(buildEvent(originalEvent, obj));
        }
        return events;
    }
    
    private static ObjectStatusEvent buildEvent(
            final ObjectStatusEvent origEvent,
            final Tuple11<Long, String, String, String, Long, String, Long, String, String,
                    Long, Map<String, String>> obj) {
        return new ObjectStatusEvent(
                null, // no mongo id
                STORAGE_CODE,
                origEvent.getAccessGroupId(),
                obj.getE1() + "",
                Math.toIntExact(obj.getE5()), // vers are always ints
                null, // no rename
                null, // not a datapalette share
                origEvent.getTimestamp(), //TODO NOW switch to object timestamp
                obj.getE3().split("-")[0],
                ObjectStatusEventType.NEW_VERSION,
                origEvent.isGlobalAccessed());
    }
    
    public static String toWSRefPath(final List<GUID> objectRefPath) {
        final List<String> refpath = new LinkedList<>();
        for (final GUID g: objectRefPath) {
            if (!g.getStorageCode().equals("WS")) {
                throw new IllegalArgumentException(String.format(
                        "GUID %s is not a workspace object", g));
            }
            refpath.add(g.getAccessGroupId() + "/" + g.getAccessGroupObjectId() + "/" +
                    g.getVersion());
        }
        return String.join(";", refpath);
    }

}
